# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

from models.base_model_ import Model
from models.media_component import MediaComponent
import re
import util

from models.media_component import MediaComponent  # noqa: E501
import re  # noqa: E501

class AcceptableServiceInfo(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, acc_bw_med_comps=None, mar_bw_ul=None, mar_bw_dl=None):  # noqa: E501
        """AcceptableServiceInfo - a model defined in OpenAPI

        :param acc_bw_med_comps: The acc_bw_med_comps of this AcceptableServiceInfo.  # noqa: E501
        :type acc_bw_med_comps: Dict[str, MediaComponent]
        :param mar_bw_ul: The mar_bw_ul of this AcceptableServiceInfo.  # noqa: E501
        :type mar_bw_ul: str
        :param mar_bw_dl: The mar_bw_dl of this AcceptableServiceInfo.  # noqa: E501
        :type mar_bw_dl: str
        """
        self.openapi_types = {
            'acc_bw_med_comps': Dict[str, MediaComponent],
            'mar_bw_ul': str,
            'mar_bw_dl': str
        }

        self.attribute_map = {
            'acc_bw_med_comps': 'accBwMedComps',
            'mar_bw_ul': 'marBwUl',
            'mar_bw_dl': 'marBwDl'
        }

        self._acc_bw_med_comps = acc_bw_med_comps
        self._mar_bw_ul = mar_bw_ul
        self._mar_bw_dl = mar_bw_dl

    @classmethod
    def from_dict(cls, dikt) -> 'AcceptableServiceInfo':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The AcceptableServiceInfo of this AcceptableServiceInfo.  # noqa: E501
        :rtype: AcceptableServiceInfo
        """
        return util.deserialize_model(dikt, cls)

    @property
    def acc_bw_med_comps(self):
        """Gets the acc_bw_med_comps of this AcceptableServiceInfo.

        Indicates the maximum bandwidth that shall be authorized by the PCF for each media component of the map. The key of the map is the media component number.  # noqa: E501

        :return: The acc_bw_med_comps of this AcceptableServiceInfo.
        :rtype: Dict[str, MediaComponent]
        """
        return self._acc_bw_med_comps

    @acc_bw_med_comps.setter
    def acc_bw_med_comps(self, acc_bw_med_comps):
        """Sets the acc_bw_med_comps of this AcceptableServiceInfo.

        Indicates the maximum bandwidth that shall be authorized by the PCF for each media component of the map. The key of the map is the media component number.  # noqa: E501

        :param acc_bw_med_comps: The acc_bw_med_comps of this AcceptableServiceInfo.
        :type acc_bw_med_comps: Dict[str, MediaComponent]
        """
        if acc_bw_med_comps is not None and len(acc_bw_med_comps) < 1:
            raise ValueError("Invalid value for `acc_bw_med_comps`, number of items must be greater than or equal to `1`")  # noqa: E501

        self._acc_bw_med_comps = acc_bw_med_comps

    @property
    def mar_bw_ul(self):
        """Gets the mar_bw_ul of this AcceptableServiceInfo.

        String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".   # noqa: E501

        :return: The mar_bw_ul of this AcceptableServiceInfo.
        :rtype: str
        """
        return self._mar_bw_ul

    @mar_bw_ul.setter
    def mar_bw_ul(self, mar_bw_ul):
        """Sets the mar_bw_ul of this AcceptableServiceInfo.

        String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".   # noqa: E501

        :param mar_bw_ul: The mar_bw_ul of this AcceptableServiceInfo.
        :type mar_bw_ul: str
        """
        if mar_bw_ul is not None and not re.search(r'^\d+(\.\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$', mar_bw_ul):  # noqa: E501
            raise ValueError("Invalid value for `mar_bw_ul`, must be a follow pattern or equal to `/^\d+(\.\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$/`")  # noqa: E501

        self._mar_bw_ul = mar_bw_ul

    @property
    def mar_bw_dl(self):
        """Gets the mar_bw_dl of this AcceptableServiceInfo.

        String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".   # noqa: E501

        :return: The mar_bw_dl of this AcceptableServiceInfo.
        :rtype: str
        """
        return self._mar_bw_dl

    @mar_bw_dl.setter
    def mar_bw_dl(self, mar_bw_dl):
        """Sets the mar_bw_dl of this AcceptableServiceInfo.

        String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".   # noqa: E501

        :param mar_bw_dl: The mar_bw_dl of this AcceptableServiceInfo.
        :type mar_bw_dl: str
        """
        if mar_bw_dl is not None and not re.search(r'^\d+(\.\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$', mar_bw_dl):  # noqa: E501
            raise ValueError("Invalid value for `mar_bw_dl`, must be a follow pattern or equal to `/^\d+(\.\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$/`")  # noqa: E501

        self._mar_bw_dl = mar_bw_dl
